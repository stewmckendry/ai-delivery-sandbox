# Tool Registry System

This document explains the architecture and usage of the dynamic tool registry system implemented in WP3b for PolicyGPT.

---

## ðŸ”§ Purpose
Enables standardized loading, invocation, and trace logging for all GPT-compatible tools and internal toolchain components.

---

## ðŸ§© Components

### 1. `tool_catalog.yaml`
- Central registry of tool metadata: tool ID, module path, class name
- Located at: `project/reference/tool_catalog.yaml`

### 2. `tool_registry.py`
- Dynamically loads tool classes from YAML
- Provides methods: `get_tool(tool_id)` and `list_tools()`
- Used by both CLI and API router

### 3. Tool Wrappers (`tool_wrappers/*.py`)
- Each defines a `Tool` class with a `.run_tool(input_dict)` method
- Optionally include CLI fallback for local testing

### 4. `api_router.py`
- Mounts `POST /tools/{tool_id}` endpoint
- Invokes tool via `ToolRegistry`
- Returns structured JSON output

---

## ðŸ“ˆ Usage Modes

### âœ… GPT Calls
- GPT can call tool by ID
- Response logged in YAML trace

### âœ… Internal Toolchains
- Other tools or chains can call `ToolRegistry().get_tool()` directly

---

## âš™ï¸ Extensibility
- Add entry in YAML â†’ implement `Tool` class
- No API changes needed
- CLI, API, and toolchain ready by default

---

## ðŸ“Œ Example

```yaml
# tool_catalog.yaml
translateDocument:
  module: app.tools.tool_wrappers.translateDocument
  class: Tool
```

```python
# tool_registry usage
registry = ToolRegistry()
tool = registry.get_tool("translateDocument")
result = tool.run_tool({"doc_id": "xyz", "target_lang": "fr"})
```

---

This modular setup accelerates new tool integration, standardizes I/O and supports fallback + trace at every stage.

---

## ðŸ§  FAQ + Advanced Topics

### ðŸ“˜ How is `/openapi.json` served?
- Automatically generated by FastAPI when `FastAPI()` is instantiated in `main.py`
- Requires no extra code
- Useful for Swagger UI (`/docs`), ReDoc (`/redoc`), and OpenAPI-compatible tools
- Yes, you can use this in a custom GPT config for OpenAPI tool schema registration

### â“ Why is OpenAPI only exposing one route?
- `/tools/{tool_id}` is a general dynamic endpoint
- Internally dispatches to any tool in `tool_catalog.yaml`
- This simplifies routing but limits automatic discovery of individual tool schemas

### ðŸ¤– How will GPT discover tools?
Three options:
1. **Static Tool List in GPT system prompt** (manual)
2. **`GET /tools` API Route** that returns catalog entries (to be added)
3. **`gpt_tools_manifest.json`** (recommended)
   - A static manifest describing tool_id, input/output schema, description, etc.
   - Can be fetched once and cached by GPT

### ðŸ•¸ï¸ Manifest vs Real-Time Fetch
- **Initial Load:** GPT can fetch manifest at session start for all tools
- **During Use:** GPT can re-fetch if memory is reset or for fallback/error handling
- **On Each Call:** Not recommended â€” too slow, risks latency + complexity

> ðŸ”® *We recommend generating a manifest JSON file and instructing GPT to load it once at session start. It can re-fetch only if needed.*

### ðŸ§ª How will parameters be validated?
Right now: `input_dict = request.json()` (no checks).

To enable validation:
1. Add `schema:` block to each tool in `tool_catalog.yaml`
2. Generate Pydantic models per tool OR validate manually
3. Optionally implement `validate(input_dict)` per tool class

Example schema block in YAML:
```yaml
translateDocument:
  module: app.tools.tool_wrappers.translateDocument
  class: Tool
  schema:
    doc_id: str
    target_lang:
      type: str
      enum: ["en", "fr"]
```

### âœ… Summary of Improvements To Be Implemented
- [x] `/tools/{tool_id}` endpoint
- [ ] Add `GET /tools` route for GPT discovery
- [ ] Generate `gpt_tools_manifest.json`
- [ ] Add `schema:` metadata to `tool_catalog.yaml`
- [ ] Add optional validation hooks per tool
- [ ] Use this schema to improve API and GPT UX