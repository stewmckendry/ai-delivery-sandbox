# Tool Registry System

This document explains the architecture and usage of the dynamic tool registry system implemented in WP3b for PolicyGPT.

---

## üîß Purpose
Enables standardized loading, invocation, and trace logging for all GPT-compatible tools and internal toolchain components.

---

## üß© Components

### 1. `tool_catalog.yaml`
- Central registry of tool metadata: tool ID, module path, class name
- Located at: `project/reference/tool_catalog.yaml`

### 2. `tool_registry.py`
- Dynamically loads tool classes from YAML
- Provides methods: `get_tool(tool_id)` and `list_tools()`
- Used by both CLI and API router

### 3. Tool Wrappers (`tool_wrappers/*.py`)
- Each defines a `Tool` class with a `.run_tool(input_dict)` method
- Optionally include CLI fallback for local testing

### 4. `api_router.py`
- Mounts `POST /tools/{tool_id}` endpoint
- Invokes tool via `ToolRegistry`
- Returns structured JSON output

---

## üìà Usage Modes

### ‚úÖ GPT Calls
- GPT can call tool by ID
- Response logged in YAML trace

### ‚úÖ Internal Toolchains
- Other tools or chains can call `ToolRegistry().get_tool()` directly

---

## ‚öôÔ∏è Extensibility
- Add entry in YAML ‚Üí implement `Tool` class
- No API changes needed
- CLI, API, and toolchain ready by default

---

## üìå Example

```yaml
# tool_catalog.yaml
translateDocument:
  module: app.tools.tool_wrappers.translateDocument
  class: Tool
```

```python
# tool_registry usage
registry = ToolRegistry()
tool = registry.get_tool("translateDocument")
result = tool.run_tool({"doc_id": "xyz", "target_lang": "fr"})
```

---

This modular setup accelerates new tool integration, standardizes I/O and supports fallback + trace at every stage.

---

## üß† FAQ + Advanced Topics

### üìò How is `/openapi.json` served?
- Automatically generated by FastAPI when `FastAPI()` is instantiated in `main.py`
- Requires no extra code
- Useful for Swagger UI (`/docs`), ReDoc (`/redoc`), and OpenAPI-compatible tools
- Yes, you can use this in a custom GPT config for OpenAPI tool schema registration

### ‚ùì Why is OpenAPI only exposing one route?
- `/tools/{tool_id}` is a general dynamic endpoint
- Internally dispatches to any tool in `tool_catalog.yaml`
- This simplifies routing but limits automatic discovery of individual tool schemas

### ü§ñ How will GPT discover tools?
Three options:
1. **Static Tool List in GPT system prompt** (manual)
2. **`GET /tools` API Route** that returns catalog entries (to be added)
3. **`gpt_tools_manifest.json`** (recommended)
   - A static manifest describing tool_id, input/output schema, description, etc.
   - Can be fetched once and cached by GPT

### üï∏Ô∏è Manifest vs Real-Time Fetch
- **Initial Load:** GPT can fetch manifest at session start for all tools
- **During Use:** GPT can re-fetch if memory is reset or for fallback/error handling
- **On Each Call:** Not recommended ‚Äî too slow, risks latency + complexity

> üîÆ *We recommend generating a manifest JSON file and instructing GPT to load it once at session start. It can re-fetch only if needed.*

### üß™ How will parameters be validated?
Right now: `input_dict = request.json()` (no checks).

To enable validation:
1. Add `schema:` block to each tool in `tool_catalog.yaml`
2. Generate Pydantic models per tool OR validate manually
3. Optionally implement `validate(input_dict)` per tool class

Example schema block in YAML:
```yaml
translateDocument:
  module: app.tools.tool_wrappers.translateDocument
  class: Tool
  schema:
    doc_id: str
    target_lang:
      type: str
      enum: ["en", "fr"]
```

### ‚úÖ Summary of Improvements To Be Implemented
- [x] `/tools/{tool_id}` endpoint
- [ ] Add `GET /tools` route for GPT discovery
- [ ] Generate `gpt_tools_manifest.json`
- [ ] Add `schema:` metadata to `tool_catalog.yaml`
- [ ] Add optional validation hooks per tool
- [ ] Use this schema to improve API and GPT UX

---

## ‚úÖ Input Validation Approach

### 1. Generic Schema-Based Validation (Default)
- Triggered if `schema:` exists in `tool_catalog.yaml`
- Attached automatically via `tool_registry.py`
- Checks:
  - All required fields present
  - Enum values are valid (if defined)

### 2. Custom Per-Tool Validation (Override Optional)
- Tool wrapper can define its own `validate()` method
- Replaces generic method when present
- Use case: dynamic rules, nested fields, advanced checks

### Summary Table
| Type         | Uses Schema in YAML | Automatically Attached | Supports Advanced Rules |
|--------------|---------------------|-------------------------|--------------------------|
| Generic      | ‚úÖ Yes              | ‚úÖ Yes                  | ‚ùå No                    |
| Custom       | ‚ùå No (manual)      | ‚ùå No (manual)          | ‚úÖ Yes                   |